// dns_resolveconf.go: Manipulate hostname resolution with the resolvconf(8) command.

package main

import (
	"os"
	"os/exec"
	"strings"
)

const resolvConfSignature = "# Generated by teletun"

// resolvconf -a ifname <<< stuff
// resolvconf -d ifname
// resolvconf -l | split-by \n\n
func ResolvconfSetInterface(ifname string, body string) error {
	cmd := exec.Command("resolvconf", "-a", ifname)
	cmd.Stdin = strings.NewReader(resolvConfSignature + "\n" + body)
	cmd.Stdout = os.Stderr
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func ResolvconfDelInterface(ifname string) error {
	cmd := exec.Command("resolvconf", "-d", ifname)
	cmd.Stdout = os.Stderr
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func ResolvconfCleanup() error {
	cmd := exec.Command("resolvconf", "-l", "*")
	// We direct stderr to /dev/null, and ignore errors, because
	// if `resolvconf -l` isn't supported, it probably means that
	// resolvconf is systemd-resolvconf (TODO: verify whether
	// Apple resolvconf or Debian resolvconf have broken -l), in
	// which case cleanup isn't nescessary, since resolved will
	// clean things up automatically (and more robustly, TBH).
	output, err := cmd.Output()
	if err != nil {
		return nil
	}

	// FIXME: This parser is probably over-fitted to openresolv.
	// Check it against Apple resolvconf and Debian resolvconf.
	lineCnt := 0
	ifname := ""
	var errs []error
	for _, line := range strings.Split(string(output), "\n") {
		switch lineCnt {
		case 0:
			ifname = strings.TrimPrefix(line, "# resolv.conf from ")
		case 1:
			if line == resolvConfSignature {
				if _, err = RoutingTable.GetInterfaceIndex(ifname); err != nil {
					err = ResolvconfDelInterface(ifname)
					if err != nil {
						errs = append(errs, err)
					}
				}
			}
		}
		lineCnt++
		if line == "" {
			lineCnt = 0
		}
	}
	if len(errs) > 0 {
		return errs[0] // XXX
	}

	return nil
}
